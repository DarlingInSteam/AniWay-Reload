from Source.Core.Base.Builders.BaseBuilder import BaseBuilder

from dublib.Methods.Filesystem import ListDir, NormalizePath

from typing import TYPE_CHECKING
import shutil
import enum
import os
from urllib.parse import urlparse, unquote

if TYPE_CHECKING:
	from Source.Core.Base.Parsers.MangaParser import MangaParser
	from Source.Core.Base.Formats.Manga import Branch, Chapter, Manga

#==========================================================================================#
# >>>>> –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –°–¢–†–£–ö–¢–£–†–´ –î–ê–ù–ù–´–• <<<<< #
#==========================================================================================#

class MangaBuildSystems(enum.Enum):
	"""–ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º —Å–±–æ—Ä–∫–∏ –≥–ª–∞–≤ –º–∞–Ω–≥–∏."""

	Simple = "simple"
	ZIP = "zip"
	CBZ = "cbz"

#==========================================================================================#
# >>>>> –û–°–ù–û–í–ù–û–ô –ö–õ–ê–°–° <<<<< #
#==========================================================================================#

class MangaBuilder(BaseBuilder):
	"""–°–±–æ—Ä—â–∏–∫ –º–∞–Ω–≥–∏."""

	#==========================================================================================#
	# >>>>> –°–ò–°–¢–ï–ú–´ –°–ë–û–†–ö–ò <<<<< #
	#==========================================================================================#

	def __cbz(self, title: "Manga", chapter: "Chapter", directory: str) -> str:
		"""–°–∏—Å—Ç–µ–º–∞ —Å–±–æ—Ä–∫–∏: *.CBZ-–∞—Ä—Ö–∏–≤."""

		ArchivePath = self.__zip(title, chapter, directory)
		OutputPath = ArchivePath[:-3] + "cbz"
		os.rename(ArchivePath, OutputPath)

		return OutputPath

	def __simple(self, title: "Manga", chapter: "Chapter", directory: str) -> str:
		"""–°–∏—Å—Ç–µ–º–∞ —Å–±–æ—Ä–∫–∏: –∫–∞—Ç–∞–ª–æ–≥ —Å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏."""

		ChapterName = self._GenerateChapterNameByTemplate(chapter)
		Volume = ""
		if self._SortingByVolumes and chapter.volume: Volume = self._GenerateVolumeNameByTemplate(chapter)
		OutputPath = f"{self._ParserSettings.common.archives_directory}/{title.used_filename}/{Volume}/{ChapterName}"
		OutputPath = NormalizePath(OutputPath)

		if not os.path.exists(OutputPath): os.makedirs(OutputPath)
		Files = ListDir(directory)
		for File in Files: shutil.move(f"{directory}/{File}", f"{OutputPath}/{File}")

		return OutputPath

	def __zip(self, title: "Manga", chapter: "Chapter", directory: str) -> str:
		"""–°–∏—Å—Ç–µ–º–∞ —Å–±–æ—Ä–∫–∏: *.ZIP-–∞—Ä—Ö–∏–≤."""

		ChapterName = self._GenerateChapterNameByTemplate(chapter)
		Volume = ""
		if self._SortingByVolumes and chapter.volume: Volume = self._GenerateVolumeNameByTemplate(chapter)
		OutputPath = f"{self._ParserSettings.common.archives_directory}/{title.used_filename}/{Volume}/{ChapterName}"
		OutputPath = NormalizePath(OutputPath)

		shutil.make_archive(OutputPath, "zip", directory)

		return OutputPath + ".zip"

	#==========================================================================================#
	# >>>>> –ü–ï–†–ï–û–ü–†–ï–î–ï–õ–Ø–ï–ú–´–ï –ú–ï–¢–û–î–´ <<<<< #
	#==========================================================================================#

	def _PostInitMethod(self):
		"""–ú–µ—Ç–æ–¥, –≤—ã–ø–æ–ª–Ω—è—é—â–∏–π—Å—è –ø–æ—Å–ª–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –æ–±—ä–µ–∫—Ç–∞."""

		self.__BuildSystemsMethods = {
			MangaBuildSystems.Simple: self.__simple,
			MangaBuildSystems.CBZ: self.__cbz,
			MangaBuildSystems.ZIP: self.__zip,
		}

	#==========================================================================================#
	# >>>>> –ü–£–ë–õ–ò–ß–ù–´–ï –ú–ï–¢–û–î–´ <<<<< #
	#==========================================================================================#

	def build_chapter(self, title: "Manga", chapter_id: int):
		"""
		–°—Ç—Ä–æ–∏—Ç –≥–ª–∞–≤—É –º–∞–Ω–≥–∏.
			title ‚Äì –¥–∞–Ω–Ω—ã–µ —Ç–∞–π—Ç–ª–∞;\n
			chapter_id ‚Äì ID —Ü–µ–ª–µ–≤–æ–π –≥–ª–∞–≤—ã;\n
			build_system ‚Äì —Å–∏—Å—Ç–µ–º–∞ —Å–±–æ—Ä–∫–∏ –≥–ª–∞–≤—ã.
		"""

		if not self._BuildSystem: self._BuildSystem = MangaBuildSystems.Simple

		TargetChapter: "Chapter" = self._FindChapter(title.branches, chapter_id)
		
		# –°–æ–∑–¥–∞–µ–º –∫—Ä–∞—Å–∏–≤–æ–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≥–ª–∞–≤—ã
		chapter_display_parts = []
		if hasattr(TargetChapter, 'volume') and TargetChapter.volume:
			chapter_display_parts.append(f"Vol.{TargetChapter.volume}")
		if hasattr(TargetChapter, 'number') and TargetChapter.number is not None:
			chapter_display_parts.append(f"Ch.{TargetChapter.number}")
		elif hasattr(TargetChapter, 'chapter') and TargetChapter.chapter is not None:
			chapter_display_parts.append(f"Ch.{TargetChapter.chapter}")
		
		chapter_display = " ".join(chapter_display_parts) if chapter_display_parts else f"Chapter {chapter_id}"
		if hasattr(TargetChapter, 'name') and TargetChapter.name:
			chapter_display += f": {TargetChapter.name}"
		SlidesCount = len(TargetChapter.slides)
		WorkDirectory = f"{self._Temper.builder_temp}/{title.used_filename}"

		Parser: "MangaParser" = title.parser
		
		# –ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–û: –ï—Å–ª–∏ –ø–∞—Ä—Å–µ—Ä –∑–∞–≥—Ä—É–∂–µ–Ω –∏–∑ JSON, –Ω—É–∂–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å _parallel_downloader
		if hasattr(Parser, 'batch_download_images'):
			# –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –ª–∏ _parallel_downloader  
			if not hasattr(Parser, '_parallel_downloader') or Parser._parallel_downloader is None:
				if hasattr(Parser, '_PostInitMethod'):
					Parser._PostInitMethod()
		
		# –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É –ø–∞—Ä—Å–µ—Ä–∞ –º–µ—Ç–æ–¥ batch_download_images
		if hasattr(Parser, 'batch_download_images'):
			import time
			start_time = time.time()
			
			# –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ URL –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏
			urls = [Slide["link"] for Slide in TargetChapter.slides]
			
			# –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞
			filenames = Parser.batch_download_images(urls)
			
			download_time = time.time() - start_time
			images_per_second = SlidesCount / download_time if download_time > 0 else 0
			
			# –ü–æ–¥—Å—á–µ—Ç —É—Å–ø–µ—à–Ω—ã—Ö –∑–∞–≥—Ä—É–∑–æ–∫
			successful = sum(1 for f in filenames if f is not None)
			failed = SlidesCount - successful
			
			# –°–ò–ù–ò–ô –õ–û–ì: –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–∫–∞—á–∞–Ω–Ω–æ–π –≥–ª–∞–≤–µ —Å –º–µ—Ç—Ä–∏–∫–∞–º–∏
			if failed > 0:
				self._SystemObjects.logger.info(f"\033[94müì• {chapter_display} - {successful}/{SlidesCount} images ({images_per_second:.1f} img/sec, {failed} failed)\033[0m")
			else:
				self._SystemObjects.logger.info(f"\033[94müì• {chapter_display} - {SlidesCount} images ({images_per_second:.1f} img/sec)\033[0m")
			
			# –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –ø—Ä–∏ –Ω–∏–∑–∫–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏
			if images_per_second < 1.0 and SlidesCount > 3:
				avg_time_per_image = download_time / SlidesCount
				self._SystemObjects.logger.warning(f"‚ö†Ô∏è Slow download detected: {avg_time_per_image:.1f}s per image (might be large files or slow server)")
			
			# –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤
			if not os.path.exists(WorkDirectory): 
				os.makedirs(WorkDirectory, exist_ok=True)
			
			for idx, (Slide, downloaded_filename) in enumerate(zip(TargetChapter.slides, filenames), start=1):
				parsed_url = urlparse(Slide["link"])
				raw_filename = parsed_url.path.split("/")[-1]
				Filename: str = unquote(raw_filename) or Slide["link"].split("/")[-1]
				Index: int = Slide["index"]
				
				if downloaded_filename:
					# –ü–µ—Ä–µ–º–µ—â–∞–µ–º —Ñ–∞–π–ª –∏–∑ temp –≤ —Ä–∞–±–æ—á—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
					MovingStatus = self._Parser.images_downloader.move_from_temp(
						WorkDirectory, Filename, f"{Index}", is_full_filename=False
					)
					MovingStatus.print_messages()
				else:
					self._SystemObjects.logger.error(f"Unable download slide \"{Filename}\" ({idx}/{SlidesCount}).")
		
		else:
			# FALLBACK: –°—Ç–∞—Ä—ã–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ (–µ—Å–ª–∏ batch_download_images –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω)
			import time
			start_time = time.time()
			
			for Slide in TargetChapter.slides:
				Link: str = Slide["link"]
				parsed_url = urlparse(Link)
				raw_filename = parsed_url.path.split("/")[-1]
				Filename: str = unquote(raw_filename) or Link.split("/")[-1]
				Index: int = Slide["index"]
				
				if not os.path.exists(WorkDirectory): os.mkdir(WorkDirectory)
				DownloadingStatus = Parser.image(Link)
				DownloadingStatus.print_messages()

				if not DownloadingStatus.has_errors:
					pass  # –£–±—Ä–∞–ª–∏ –ª–∏—à–Ω–∏–µ DEBUG –ª–æ–≥–∏
				else: 
					self._SystemObjects.logger.error(f"Unable download slide \"{Filename}\". Response code: {DownloadingStatus.code}.")

				MovingStatus = self._Parser.images_downloader.move_from_temp(WorkDirectory, Filename, f"{Index}", is_full_filename = False)
				MovingStatus.print_messages()
			
			download_time = time.time() - start_time
			images_per_second = SlidesCount / download_time if download_time > 0 else 0
			
			# –°–ò–ù–ò–ô –õ–û–ì: –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–∫–∞—á–∞–Ω–Ω–æ–π –≥–ª–∞–≤–µ —Å –º–µ—Ç—Ä–∏–∫–∞–º–∏ (–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥)
			self._SystemObjects.logger.info(f"\033[94müì• {chapter_display} - {SlidesCount} images ({images_per_second:.1f} img/sec, sequential)\033[0m")
		
		# –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –í—ã–∑—ã–≤–∞–µ–º —Å–∏—Å—Ç–µ–º—É —Å–±–æ—Ä–∫–∏ –¢–û–õ–¨–ö–û –û–î–ò–ù –†–ê–ó –ø–æ—Å–ª–µ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –≤—Å–µ—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
		self.__BuildSystemsMethods[self._BuildSystem](title, TargetChapter, WorkDirectory)

		shutil.rmtree(WorkDirectory)

	def build_branch(self, title: "Manga", branch_id: int | None = None):
		"""
		–°—Ç—Ä–æ–∏—Ç –≤–µ—Ç–≤—å –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –º–∞–Ω–≥–∏.
			branch_id ‚Äì ID –≤—ã–±—Ä–∞–Ω–Ω–æ–π –≤–µ—Ç–≤–∏ (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å–∞–º–∞—è –¥–ª–∏–Ω–Ω–∞—è).
		"""

		TargetBranch: "Branch" = self._SelectBranch(title.branches, branch_id)
		
		# –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–ª—É—á–∞–π –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –≤–µ—Ç–æ–∫/–≥–ª–∞–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è 18+ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –±–µ–∑ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏)
		if TargetBranch is None:
			self._SystemObjects.logger.warning("No branches found in title. Title may have no chapters (e.g. 18+ content without authentication).")
			return
		
		if not TargetBranch.chapters:
			self._SystemObjects.logger.warning(f"Branch {TargetBranch.id} has no chapters. Skipping build.")
			return
		
		# –ü–æ–¥—Å—á–µ—Ç –æ–±—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ —Ç–∞–π—Ç–ª–µ
		total_images = sum(len(ch.slides) for ch in TargetBranch.chapters)
		
		# –°–ò–ù–ò–ô –õ–û–ì: –ü–µ—Ä–µ—Ö–æ–¥ –∫ –±–∏–ª–¥–∏–Ω–≥—É —Å –æ–±—â–∏–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π  
		self._SystemObjects.logger.info(f"\033[94müî® Starting build: {len(TargetBranch.chapters)} chapters, {total_images} images total\033[0m")
		
		# –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã –≤ —Å–ø–∏—Å–∫–µ –≥–ª–∞–≤
		chapter_ids = [ch.id for ch in TargetBranch.chapters]
		if len(chapter_ids) != len(set(chapter_ids)):
			duplicates = [ch_id for ch_id in set(chapter_ids) if chapter_ids.count(ch_id) > 1]
			self._SystemObjects.logger.warning(f"Found duplicate chapter IDs in branch: {duplicates}")
		
		# –°—á–µ—Ç—á–∏–∫ —Å–∫–∞—á–∞–Ω–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
		downloaded_images = 0
		
		for CurrentChapter in TargetBranch.chapters: 
			self.build_chapter(title, CurrentChapter.id)
			downloaded_images += len(CurrentChapter.slides)
			
			# –°–ò–ù–ò–ô –õ–û–ì: –ü—Ä–æ–≥—Ä–µ—Å—Å —Å–∫–∞—á–∞–Ω–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
			self._SystemObjects.logger.info(f"\033[94müìä Downloaded: {downloaded_images}/{total_images} images ({downloaded_images/total_images*100:.1f}%)\033[0m")
		
		# –°–ò–ù–ò–ô –õ–û–ì: –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –±–∏–ª–¥–∏–Ω–≥–∞ –∏ –ø–µ—Ä–µ—Ö–æ–¥ –∫ –∏–º–ø–æ—Ä—Ç—É
		self._SystemObjects.logger.info(f"\033[94m‚úÖ Build completed ‚Üí Starting import phase\033[0m")

	def select_build_system(self, build_system: str | None):
		"""
		–ó–∞–¥–∞—ë—Ç —Å–∏—Å—Ç–µ–º—É —Å–±–æ—Ä–∫–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞.
			build_system ‚Äì –Ω–∞–∑–≤–∞–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã —Å–±–æ—Ä–∫–∏.
		"""

		self._BuildSystem = MangaBuildSystems(build_system) if build_system else None